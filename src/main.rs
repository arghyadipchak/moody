mod cli;
mod moodle;

use std::{
  fs::{self, File},
  io::{self, Write},
  path::{Path, PathBuf},
};

use chrono::DateTime;
use clap::Parser;
use serde::{Deserialize, Serialize};

use cli::{Cli, Commands};
use moodle::{Error, MAssignment, MUser, Moodle};

const MOODY_DICLAIMER: &str =
  "# Generated by Moody (https://github.com/arghyadipchak/moody)";

macro_rules! unwrap_return {
  ($expr:expr) => {
    match $expr {
      Ok(val) => val,
      Err(err) => {
        eprintln!("{err}");
        return;
      }
    }
  };
}

#[derive(Deserialize, Serialize)]
struct Assignment {
  id: u64,
  name: String,
  max_grade: f32,
  submissions: Vec<Submission>,
}

#[derive(Deserialize, Serialize)]
struct Submission {
  user: MUser,
  graded: bool,
  late: u64,
  grade: f32,
  feedback: String,
  files: Vec<PathBuf>,
}

impl Submission {
  fn new(user: MUser, late: u64, files: Vec<PathBuf>) -> Self {
    Self {
      user,
      graded: false,
      late,
      grade: 0.0,
      feedback: String::new(),
      files,
    }
  }
}

#[derive(Debug, thiserror::Error)]
#[error("Download error :: {0}")]
pub enum UpDownError {
  IO(#[from] io::Error),
  Moodle(#[from] Error),
  Serialize(#[from] serde_yaml::Error),
}

#[allow(clippy::similar_names)]
fn download_submissions(
  mclient: &Moodle,
  course_id: u64,
  assignment_id: u64,
  output_file: Option<PathBuf>,
) -> Result<(), UpDownError> {
  let mcourse = mclient.get_course_assignments(course_id)?;
  let massignment = mcourse.get_assignment(assignment_id)?;
  let msubmissions = mclient.get_submissions(assignment_id)?;

  let a_path = &PathBuf::from(format!("assignment_{assignment_id}"));

  let submissions = msubmissions
    .iter()
    .filter_map(|msub| {
      let userid = msub.userid;
      let u_path = a_path.join(format!("user_{userid}"));
      let user = match mclient.get_user(userid) {
        Ok(u) => u,
        Err(err) => {
          eprintln!("{err}");
          return None;
        }
      };

      if !msub.files.is_empty() {
        if let Err(err) = fs::create_dir_all(&u_path) {
          eprintln!("{err}");
          return None;
        }
      }

      let files = msub
        .files
        .iter()
        .filter_map(|f| {
          let fpath = u_path.join(f.fullpath());
          if let Err(err) = mclient.download_file(f, &fpath) {
            eprintln!("{err}");
            None
          } else {
            Some(fpath)
          }
        })
        .collect();

      Some(Submission::new(
        user,
        massignment.calculate_late(msub),
        files,
      ))
    })
    .collect();

  let out_file = output_file
    .unwrap_or_else(|| PathBuf::from(format!("ass{assignment_id}.yml")));
  let fh = File::create(&out_file)?;

  write!(&fh, "{MOODY_DICLAIMER}\n\n")?;
  serde_yaml::to_writer(
    &fh,
    &Assignment {
      id: massignment.id,
      name: format!("{} ({})", massignment.name, mcourse.fullname),
      max_grade: massignment.max_grade,
      submissions,
    },
  )?;

  println!("{}", out_file.to_string_lossy());

  Ok(())
}

#[allow(clippy::similar_names)]
fn upload_grades(
  mclient: &Moodle,
  fpath: impl AsRef<Path>,
) -> Result<(), UpDownError> {
  let assignment =
    serde_yaml::from_reader::<_, Assignment>(File::open(fpath)?)?;

  let submissions = assignment.submissions;
  let massignment = MAssignment {
    id: assignment.id,
    name: assignment.name,
    max_grade: assignment.max_grade,
    duedate: DateTime::default(),
  };

  submissions
    .iter()
    .filter(|s| s.graded)
    .for_each(|submission| {
      if let Err(err) = mclient.upload_grade(
        &massignment,
        &submission.user,
        submission.grade,
        Some(&submission.feedback),
      ) {
        eprintln!("{err}");
      }
    });

  Ok(())
}

fn main() {
  let cli = Cli::parse();

  let mclient =
    unwrap_return!(Moodle::new(&cli.base_url, &cli.username, &cli.password));
  println!("Connected to Moodle!\n");

  match cli.command {
    Commands::ListAssignments { course_id } => {
      println!(
        "{}",
        unwrap_return!(mclient.get_course_assignments(course_id))
      );
    }
    Commands::DownloadSubmissions {
      course_id,
      assignment_id,
      output_file,
    } => {
      unwrap_return!(download_submissions(
        &mclient,
        course_id,
        assignment_id,
        output_file
      ));
    }
    Commands::UploadGrades { file } => {
      unwrap_return!(upload_grades(&mclient, file));
    }
  }
}
